МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 1 з дисципліни
скриптові мови програмування





Виконав:                                                                           Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Гущин М. В.						          Сокорчук Ігор Петрович










Харків 2025

ЗАВДАННЯ

     Ознайомитися з основними командами Bash для роботи з файлами та текстовими даними, навчитися використовувати команди select, ls, awk, sort, uniq, tee, cat, sed, iconv тощо. Розробити Bash-скрипт для перетворення CSV-файла розкладу занять, експортованого з сайту cist.nure.ua, у формат, придатний для імпорту в Google Календар. Скрипт повинен вміти працювати з вибраним користувачем або автоматично визначеним CSV-файлом розкладу, сортувати та фільтрувати дані, а також форматувати їх у відповідності до вимог Google Календаря. 
     У результаті має створюватися файл Google_TimeTable_??_??_20??.csv з відформатованими даними. Скрипт має обробляти помилки (відсутність файлу, групи, проблеми з доступом або обробкою), бути виконуваним для всіх користувачів, але редагованим лише власником.


ХІД РОБОТИ
     Спочатку створюється новий файл скрипта з назвою pzpi-23-5-hushchyn-mykhailo-task1, у якому зазначається, що він є Bash-скриптом за допомогою шебангу #!/bin/bash. Далі задається змінна VERSION зі значенням "1.0", логічна змінна QUIET, яка керує виведенням у консоль, та змінні group і file, що будуть зберігати назву групи і шлях до CSV-файлу відповідно.
     
      1. #!/bin/bash
      2. 
      3. VERSION="1.0"
      4. QUIET=false
      5. group=""
      6. file=""
      
     Потім реалізується цикл while, який обробляє аргументи командного рядка. Якщо вказано --help, виводиться інструкція щодо використання скрипта і виконання припиняється.
      
      9. while [[ "$#" -gt 0 ]]; do
      10.     case $1 in
      11.         --help)
      12.             echo "Usage: $0 [options] [group] [file]"
      13.             echo "Options:"
      14.             echo "  --help        Show this help message and exit"
      
     Аналогічно, опція --version виводить номер версії скрипта. Прапор -q або --quiet активує беззвучний режим.
      
      15.             echo "  --version     Show version information and exit"
      16.             echo "  -q, --quiet   Suppress standard output"
      17.             exit 0
      18.             ;;
      19.         --version)
      20.             echo "$0 version $VERSION"
      21.             exit 0
      22.             ;;
      23.         -q|--quiet)
      24.             QUIET=true
      25.             ;;
      
     Якщо зустрічається аргумент, який не починається з дефісу і закінчується на .csv, він інтерпретується як файл, інакше — як назва академічної групи.
      
      26.         *)
      27.            if [[ -z "$file" && "$1" != -* && "$1" == *.csv ]]; then
      28.                 file="$1"  # Записуємо перший аргумент як файл
      29.             elif [[ -z "$group" && "$1" != -* ]]; then
      30.                 group="$1"
      
     Якщо аргумент не відповідає жодному з очікуваних форматів, скрипт повідомляє про невідому опцію і завершує виконання з помилкою.
      
      31.             else
      32.                 echo "Unknown option: $1" >&2
      33.                 exit 1
      34.             fi
      35.             ;;
      36.     esac
      37.     shift
      38. done
      
     Якщо користувач не вказав файл, скрипт викликає select, щоб запропонувати вибрати один із файлів у поточній директорії, які мають шаблон імені TimeTable_??_??_20??.csv. Якщо обраний файл не існує або недоступний для читання, виводиться повідомлення про помилку.
     
      40. if [[ -z "$file" ]]; then
      41.     select file in $(ls TimeTable_??_??_20??.csv 2>/dev/null | sort); do
      42.         [[ -n "$file" ]] && break
      43.         echo "Помилка: Невірний вибір. Спробуйте ще раз."
      44.     done
      45. fi	
      47. if [[ ! -r "$file" ]]; then
      48.     echo "Помилка: файл '$file' не знайдено або він недоступний." >&2
      49.     exit 1
      50. fi
      
     Далі скрипт створює тимчасовий файл temp_utf8.csv, в який перетворює початковий файл з кодування Windows-1251 у UTF-8, очищаючи символи переносу рядка Windows-формату. Якщо конвертація не вдалася, виводиться помилка.
     
      52. date_suffix=$(basename "$file" | grep -o "[0-9]\{2\}_[0-9]\{2\}_20[0-9]\{2\}")
      53. utf8_file="temp_utf8.csv"
      54. 
      55. sed 's/\r/\n/g' "$file" | iconv -f cp1251 -t UTF-8 > "$utf8_file" || {
      56.     echo "Помилка: не вдалося конвертувати файл '$file' у UTF-8." >&2
      57.     exit 1
      58. }
      59. 
      60. file="$utf8_file"
      
     Якщо групу не було вказано як аргумент, скрипт зчитує всі унікальні назви груп з першої колонки CSV-файлу, використовуючи awk, і пропонує користувачу вибрати одну. Якщо у файлі лише одна група — вона вибирається автоматично.
     
      63. if [[ -z "$group" ]]; then
      64.     mapfile -t groups < <(awk -F',' 'NR > 1 { split($1, a, " "); gsub(/"/, "", a[1]); print a[1] }' "$file" | sort -V | uniq)
      65.     if [[ ${#groups[@]} -eq 1 ]]; then
      66.         group="${groups[0]}"
      67.         echo "Єдина доступна група: $group"
      68.     else
      69.         echo "Виберіть академічну групу:"
      70.         select group in "${groups[@]}"; do
      71.             if [[ -n "$group" ]]; then
      72.                 break
      73.             fi
      74.             echo "Помилка: Невірний вибір. Спробуйте ще раз."
      75.         done
      76.     fi
      77. fi
      
     У разі, якщо QUIET неактивний, скрипт повідомляє, яку групу було вибрано. Формується назва фінального CSV-файлу у форматі Google_TimeTable_дата.csv, де дата береться з імені вхідного файлу.
     
      79. $QUIET ||echo "Ви вибрали: $group"
      80. 
      81. output_file="Google_TimeTable_${date_suffix}.csv"
      
     Потім за допомогою awk відфільтровуються рядки, що належать обраній групі, витягуються потрібні поля: назва предмета, дата й час початку та завершення, опис. Також очищаються лапки та роздільники. Усі ці дані записуються у новий CSV-файл (дод. В).
     Другий блок awk перетворює формат дати з дд.мм.рррр на формат мм/дд/рррр, який приймає Google Календар, та оновлює файл.
     
      117. awk -F',' 'BEGIN {OFS=","}
      118. NR > 0 {
      119.     
      120.     	split($2, date, ".");
      121.   	$2 = date[2] "/" date[1] "/" date[3];
      122.  	gsub(/"/, "", $2);  
      123. 	$2 = "\"" $2 "\"";
      124. 
      125. 	split($4, date, ".");
      126.   	$4 = date[2] "/" date[1] "/" date[3];
      127.  	gsub(/"/, "", $4);  
      128. 	$4 = "\"" $4 "\"";
      129. 	
      130. 
      131.     print $1, $2, $3, $4, $5, $6;
      132. 
      133. }' "$output_file" > "$output_file.tmp" && mv "$output_file.tmp" "$output_file"
     
     Далі файл сортується за датою і часом початку події, щоб забезпечити хронологічний порядок.
     
      136. sort -t',' -k2,2 -k3,3 "$output_file" > "$output_file.tmp" && mv "$output_file.tmp" "$output_file"
     
     На наступному етапі створюються два асоціативні масиви lecture_number і lab_number для відстеження кількості лекцій і лабораторних занять за предметами. 
     
      138. declare -A lecture_number
      139. declare -A lab_number
     
     У фінальному блоці awk виконується нумерація занять. У фінальному блоці awk виконується нумерація занять. Для лабораторних враховується окрема логіка: вони поєднуються в пари і нумеруються відповідно до половини кількості. Лекції нумеруються просто — за порядком появи
     Також у цьому блоці здійснюється перетворення часу з 24-годинного формату у 12-годинний з суфіксами AM/PM, які очікує Google Календар. Після всіх обробок фінальний файл перезаписується (дод. Г) .
     Якщо QUIET неактивний, скрипт виводить вміст сформованого файлу та повідомляє, що файл готовий до імпорту в Google Календар.
      
      221. $QUIET || cat "$output_file"
      222. 
      223. $QUIET || echo "Файл '$output_file' готовий для імпорту в Google Календар."
      
     На завершення скрипт успішно завершує виконання з кодом 0.
     
     
     

      

      ВИСНОВКИ
      Під час роботи було створено Bash-скрипт, який перетворює CSV-файл розкладу з сайту cist.nure.ua у формат, придатний для імпорту в Google Календар. Скрипт обробляє аргументи, дозволяє обрати файл і групу, конвертує кодування у UTF-8, фільтрує і сортує записи, змінює формат дати й часу, а також нумерує лекції і лабораторні заняття з урахуванням особливостей. Реалізована обробка помилок і виведення повідомлень для користувача. В результаті формується готовий до імпорту файл, що значно полегшує роботу з розкладом.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
     ДОДАТОК А
     Посилання на YouTube
      
      Відеозапис презентації результатів лабораторної роботи: https://youtu.be/p-PkpNBsqaM
      00:00 Привітання
      00:27 Опис вхідних параметрів
      02:00 Вибір файлу для обробки
      02:41 Створення тимчасового файлу
      03:36 Вибір групи
      04:20 Формування вихідного файлу
      04:29 Формування полів
      05:40 Форматування дати
      06:09 Нумерація занять
      07:11 Форматування часу
      07:55 Вивід результату
      08:23 Демонстрація роботи
      

    ДОДАТОК Б
    
    GitHub репозиторій: https://github.com/NureHushchynMykhailo/smp-pzpi-23-5-hushchyn-mykhailo/blob/main/Lab1/smp-pzpi-23-5-hushchyn-mykhailo-lab1/smp-pzpi-23-5-hushchyn-mykhailo-lab1-code
      
      
      
      
      

     ДОДАТОК В
     
     
      83. awk -F',' -v grp="$group " 'BEGIN {
      84.     OFS = ",";
      85.     print "Subject,Start Date,Start Time,End Date,End Time,Description"
      86. }
      87. NR > 1 && $1 ~ grp {
      88.     gsub(/;/, ",", $0);
      89.     gsub(/"/, "", $1); gsub(/"/, "", $2); gsub(/"/, "", $3); gsub(/"/, "", $5); gsub(/"/, "", $12);
      90. 
      91.     for (i = 2; i <= NF; i++) {
      92.         gsub(/"/, "", $i);
      93.         if ($i ~ /^[0-9]{2}\.[0-9]{2}\.[0-9]{4}$/) {
      94.             start_date = "\"" $i "\"";
      95.             gsub(/"/, "", $(i+1));
      96.             start_time = "\"" $(i+1) "\"";
      97.             gsub(/"/, "", $(i+2));
      98.             end_date = "\"" $i "\"";
      99.             gsub(/"/, "", $(i+3));
      100.             end_time = "\"" $(i+3) "\"";
      101.             gsub(/"/, "", $(i+10));
      102.             description = "\"" $(i+10) "\"";
      103.             break;
      104.         } else {
      105.             subject = subject OFS $i;
      106.             $i = "";
      107.         }
      108.     }
      109. 
      110.     subject = "\"" $1 "\"";
      111. 
      112.     formatted_subject = subject OFS start_date OFS start_time OFS end_date OFS end_time OFS description;
      113. 
      114.     print formatted_subject
      115. }' "$file" > "$output_file"
      
      
      
      
      
      
      
      
      
      
      
      
     ДОДАТОК Г
      
      141. awk -F',' -v grp="$group " 'BEGIN {
      142.    
      143.     print "Subject,Start Date,Start Time,End Date,End Time,Description"
      144. }
      145. NR > 1 {
      146.     subject_name = $6;
      147. 
      148.       if (subject_name ~ /Лб/) {
      149.                if (!(subject_name in lab_number)) lab_number[subject_name] = 1;
      150. 
      151.               if (lab_number[subject_name] % 2 == 1) {
      152.                       gsub(/"/, "", $1); 
      153.             sub(/ПЗПІ-[0-9]+-[0-9]+ - /, "", $1);  
      154.             $1 = "\"" $1 " №" int((lab_number[subject_name] + 1) / 2) "\"";
      155.         } else {
      156.                         gsub(/"/, "", $1);  
      157.             sub(/ПЗПІ-[0-9]+-[0-9]+ - /, "", $1); 
      158.             $1 = "\"" $1 " №" int(lab_number[subject_name] / 2) "\"";
      159.         }
      160. 
      161.        
      162.         lab_number[subject_name]++;
      163. 
      164.     } else {
      165.        
      166.         if (!(subject_name in lecture_number)) lecture_number[subject_name] = 0;
      167.         lecture_number[subject_name]++;
      168.         
      169.         gsub(/"/, "", $1);  
      170.         sub(/ПЗПІ-[0-9]+-[0-9]+ - /, "", $1);  
      171.         $1 = "\"" $1 " №" lecture_number[subject_name] "\"";
      172.     }
      173. 
      174. 	gsub(/"/, "", $3); 
      175. gsub(/"/, "", $5); 
      176. 
      177.  split($3, time, ":");
      178.     hour = time[1];
      179.     minute = time[2];
      180.     
      181.    
      182.     if (hour == 0) {
      183.         hour = 12;
      184.         suffix = "AM";
      185.     } else if (hour == 12) {
      186.         suffix = "PM";
      187.     } else if (hour > 12) {
      188.         hour = hour - 12;
      189.         suffix = "PM";
      190.     } else {
      191.         suffix = "AM";
      192.     }
      193. 
      194.     $3 = hour ":" minute " " suffix;
      195. 
      196.     
      197.     split($5, time, ":");
      198.     hour = time[1];
      199.     minute = time[2];
      200.     
      201.         if (hour == 0) {
      202.         hour = 12;
      203.         suffix = "AM";
      204.     } else if (hour == 12) {
      205.         suffix = "PM";
      206.     } else if (hour > 12) {
      207.         hour = hour - 12;
      208.         suffix = "PM";
      209.     } else {
      210.         suffix = "AM";
      211.     }
      212. 
      213.     $5 = hour ":" minute " " suffix;
      214. $3 = "\"" $3 "\"";
      215. $5 = "\"" $5 "\"";
      216. 
      217.         print $1, $2, $3, $4, $5, $6;
      218. }' OFS=',' "$output_file" > "$output_file.tmp" && mv "$output_file.tmp" "$output_file"
      
      
      
      
